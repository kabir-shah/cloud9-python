# IPython log file

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
a = numpy.random.randn(1000)
a = np.random.randn(1000)
plt.hist(a)
#[Out]# (array([   8.,   26.,  102.,  228.,  286.,  190.,  129.,   27.,    2.,    2.]), array([-3.16196121, -2.46458943, -1.76721764, -1.06984585, -0.37247407,
#[Out]#         0.32489772,  1.02226951,  1.71964129,  2.41701308,  3.11438486,
#[Out]#         3.81175665]), <a list of 10 Patch objects>)
plt.savefig("1.3.2/Histogram")
# Tue, 04 Dec 2018 17:39:48
# Kabir Shah 1.3.2 IPython Log
# Tue, 04 Dec 2018 17:40:03
5 + 3
#[Out]# 8
# Tue, 04 Dec 2018 17:40:26
7*2
#[Out]# 14
# Tue, 04 Dec 2018 17:40:34
7*2.
#[Out]# 14.0
# Tue, 04 Dec 2018 17:40:59
# (7*2) gives an int, while (7*2.) gives a float
# Tue, 04 Dec 2018 17:41:47
# If one of the arguments to the multiplication is a float, then the result will also be a float. This is to preserve any extra precision given in the arguments in the result.
# Tue, 04 Dec 2018 17:42:15
7/2
#[Out]# 3
# Tue, 04 Dec 2018 17:42:18
7/2.
#[Out]# 3.5
# Tue, 04 Dec 2018 17:43:36
# 7b: int/int returns an int, while int/float returns a float. This is also to have the precision of the arguments when they are floating point, and preserve it in the result when they are floating point. When they are both ints, the result will be given to the same precision as an integer.
# Tue, 04 Dec 2018 17:44:13
# 8. Assignment
# Tue, 04 Dec 2018 17:45:34
student_age = 16 # note: I'm 14 but the directions say 16 ¯\_(ツ)_/¯
# Tue, 04 Dec 2018 17:46:03
# 9. Assignment
# Tue, 04 Dec 2018 17:46:26
23 ** 43
#[Out]# 35834136918934220777541995677272642015423987712183913488967L
# Tue, 04 Dec 2018 17:47:12
# 23 ^ 43 = 35834136918934220777541995677272642015423987712183913488967
# Wed, 05 Dec 2018 18:08:11
%run 1.3.2/Shah_1.3.2.py
# Wed, 05 Dec 2018 18:09:52
# 11: Editing many lines in the code editor first before running allows for previous statements to be edited and configured as needed. In contrast, using the Python shell is helpful for the instant feedback and for prototyping simple things. It is not useful for larger programs that need to be edited as developed.
# Wed, 05 Dec 2018 18:11:17
# 12: Scratch and App Inventor used a hierarchical structure and allowed the user to drag other code blocks inside of if/else chunks.
# Wed, 05 Dec 2018 18:13:28
# 13: Using a docstring for a function allows you to document what a function does to refer back to later if forgotten. Also, it allows other readers of your code and team members to see what a specific function does, what parameters it takes, and what it returns.
# Wed, 05 Dec 2018 18:18:45
# 14: Destroying local variables once a block is done executing allows for unused memory to be reused instead of taking up more space. It also allows for variable names to be small and concise, because they do not have to be unique. This is because variables will be destroyed and their names will become available for use again. Instead of cluttering the amount of variables available for use, they will be destroyed when they aren't needed anymore.
# Wed, 05 Dec 2018 18:20:21
%logstop
